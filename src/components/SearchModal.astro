---
const rawBaseUrl = import.meta.env.BASE_URL;
const baseUrl = rawBaseUrl === '/' ? '' : rawBaseUrl.replace(/\/$/, '');
---

<div
  id="search-modal"
  class="fixed inset-0 z-50 hidden"
  role="dialog"
  aria-modal="true"
  aria-label="Rechercher"
>
  <!-- Backdrop -->
  <div class="fixed inset-0 bg-surface-950/60 backdrop-blur-sm" data-search-backdrop></div>

  <!-- Modal -->
  <div class="fixed inset-x-4 top-[10%] sm:inset-x-auto sm:left-1/2 sm:-translate-x-1/2 sm:w-full sm:max-w-lg">
    <div class="card shadow-2xl overflow-hidden border-surface-200/50 dark:border-surface-700/50">
      <!-- Search input -->
      <div class="relative">
        <svg
          class="absolute left-4 top-1/2 -translate-y-1/2 w-5 h-5 text-surface-400"
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
          aria-hidden="true"
        >
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            stroke-width="2"
            d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"
          />
        </svg>
        <input
          type="search"
          id="search-input"
          class="w-full pl-12 pr-12 py-4 text-lg bg-transparent border-b border-surface-200 dark:border-surface-700 focus:outline-none text-surface-900 dark:text-white placeholder-surface-400 font-light"
          placeholder="Rechercher..."
          autocomplete="off"
        />
        <kbd class="absolute right-4 top-1/2 -translate-y-1/2 px-2 py-0.5 text-xs font-mono text-surface-400 bg-surface-100 dark:bg-surface-800 border border-surface-200 dark:border-surface-700 rounded hidden sm:inline-flex">
          Esc
        </kbd>
      </div>

      <!-- Results -->
      <div id="search-results" class="max-h-[60vh] overflow-y-auto scrollbar-thin">
        <!-- Initial state -->
        <div id="search-empty" class="p-8 text-center text-surface-500 dark:text-surface-400">
          <div class="w-12 h-12 mx-auto mb-4 rounded-full bg-primary-500/10 flex items-center justify-center">
            <svg class="w-6 h-6 text-primary-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
            </svg>
          </div>
          <p class="font-medium">Commencez a taper pour rechercher...</p>
          <p class="text-sm mt-1 text-surface-400">Recherchez dans les posts et les hashtags</p>
        </div>

        <!-- Loading state -->
        <div id="search-loading" class="p-8 text-center hidden">
          <div class="inline-block w-6 h-6 border-2 border-primary-500 border-t-transparent rounded-full animate-spin"></div>
        </div>

        <!-- Results list -->
        <ul id="search-results-list" class="divide-y divide-surface-100 dark:divide-surface-800 hidden" role="listbox">
        </ul>

        <!-- No results -->
        <div id="search-no-results" class="p-8 text-center text-surface-500 dark:text-surface-400 hidden">
          <div class="w-12 h-12 mx-auto mb-4 rounded-full bg-surface-100 dark:bg-surface-800 flex items-center justify-center">
            <svg class="w-6 h-6 text-surface-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.172 16.172a4 4 0 015.656 0M9 10h.01M15 10h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
          </div>
          <p class="font-medium">Aucun resultat trouve</p>
          <p class="text-sm mt-1 text-surface-400">Essayez avec d'autres mots-cles</p>
        </div>
      </div>
    </div>
  </div>
</div>

<script define:vars={{ baseUrl }}>
  let MiniSearch = null;
  let searchIndex = null;
  let miniSearch = null;
  let selectedIndex = -1;

  async function loadSearchIndex() {
    if (searchIndex && miniSearch) return;

    try {
      // Load MiniSearch from CDN
      if (!MiniSearch) {
        const module = await import('https://esm.sh/minisearch@7.0.2');
        MiniSearch = module.default;
      }

      const response = await fetch(`${baseUrl}/search-index.json`);
      searchIndex = await response.json();

      miniSearch = new MiniSearch({
        fields: ['content', 'hashtags'],
        storeFields: ['id', 'content', 'hashtags', 'date', 'url', 'excerpt'],
        searchOptions: {
          boost: { hashtags: 2 },
          fuzzy: 0.2,
          prefix: true,
        },
      });

      miniSearch.addAll(searchIndex);
    } catch (error) {
      console.error('Failed to load search index:', error);
    }
  }

  function initSearch() {
    const modal = document.getElementById('search-modal');
    const input = document.getElementById('search-input');
    const backdrop = document.querySelector('[data-search-backdrop]');
    const resultsList = document.getElementById('search-results-list');
    const emptyState = document.getElementById('search-empty');
    const loadingState = document.getElementById('search-loading');
    const noResultsState = document.getElementById('search-no-results');

    if (!modal || !input || !resultsList) return;

    // Open search
    const openSearch = async () => {
      modal.classList.remove('hidden');
      document.body.style.overflow = 'hidden';
      input.focus();
      selectedIndex = -1;

      // Load search index
      loadingState?.classList.remove('hidden');
      emptyState?.classList.add('hidden');
      await loadSearchIndex();
      loadingState?.classList.add('hidden');
      emptyState?.classList.remove('hidden');
    };

    // Close search
    const closeSearch = () => {
      modal.classList.add('hidden');
      document.body.style.overflow = '';
      input.value = '';
      resultsList.innerHTML = '';
      resultsList.classList.add('hidden');
      emptyState?.classList.remove('hidden');
      noResultsState?.classList.add('hidden');
      selectedIndex = -1;
    };

    // Perform search
    const performSearch = (query) => {
      if (!miniSearch || !query.trim()) {
        resultsList.classList.add('hidden');
        emptyState?.classList.remove('hidden');
        noResultsState?.classList.add('hidden');
        return;
      }

      emptyState?.classList.add('hidden');
      const results = miniSearch.search(query);

      if (results.length === 0) {
        resultsList.classList.add('hidden');
        noResultsState?.classList.remove('hidden');
        return;
      }

      noResultsState?.classList.add('hidden');
      resultsList.classList.remove('hidden');

      resultsList.innerHTML = results.slice(0, 10).map((result, index) => `
        <li role="option" aria-selected="${index === selectedIndex}">
          <a
            href="${result.url}"
            class="block p-4 hover:bg-primary-500/5 dark:hover:bg-primary-500/10 transition-colors ${index === selectedIndex ? 'bg-primary-500/5 dark:bg-primary-500/10' : ''}"
            data-result-index="${index}"
          >
            <p class="text-surface-800 dark:text-surface-200 line-clamp-2">${result.excerpt}</p>
            <div class="flex items-center gap-2 mt-2">
              <span class="text-xs font-mono text-surface-400">
                ${new Date(result.date).toLocaleDateString('fr-FR')}
              </span>
              ${result.hashtags ? `<span class="text-xs text-primary-500">${result.hashtags.split(' ').map(t => '#' + t).join(' ')}</span>` : ''}
            </div>
          </a>
        </li>
      `).join('');

      selectedIndex = -1;
    };

    // Keyboard navigation
    const handleKeydown = (e) => {
      const items = resultsList.querySelectorAll('a[data-result-index]');

      switch (e.key) {
        case 'ArrowDown':
          e.preventDefault();
          selectedIndex = Math.min(selectedIndex + 1, items.length - 1);
          updateSelection(items);
          break;
        case 'ArrowUp':
          e.preventDefault();
          selectedIndex = Math.max(selectedIndex - 1, -1);
          updateSelection(items);
          break;
        case 'Enter':
          if (selectedIndex >= 0 && items[selectedIndex]) {
            items[selectedIndex].click();
          }
          break;
        case 'Escape':
          closeSearch();
          break;
      }
    };

    const updateSelection = (items) => {
      items.forEach((item, index) => {
        const li = item.parentElement;
        if (index === selectedIndex) {
          item.classList.add('bg-primary-500/5', 'dark:bg-primary-500/10');
          li?.setAttribute('aria-selected', 'true');
          item.scrollIntoView({ block: 'nearest' });
        } else {
          item.classList.remove('bg-primary-500/5', 'dark:bg-primary-500/10');
          li?.setAttribute('aria-selected', 'false');
        }
      });
    };

    // Event listeners
    window.addEventListener('open-search', openSearch);

    // Cmd+K / Ctrl+K
    document.addEventListener('keydown', (e) => {
      if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
        e.preventDefault();
        if (modal.classList.contains('hidden')) {
          openSearch();
        } else {
          closeSearch();
        }
      }
    });

    backdrop?.addEventListener('click', closeSearch);

    input.addEventListener('input', (e) => {
      performSearch(e.target.value);
    });

    input.addEventListener('keydown', handleKeydown);
  }

  initSearch();
  document.addEventListener('astro:after-swap', initSearch);
</script>

<style>
  .line-clamp-2 {
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }
</style>
