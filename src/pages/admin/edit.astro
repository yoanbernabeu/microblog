---
import AdminLayout from '@layouts/AdminLayout.astro';

const baseUrl = import.meta.env.BASE_URL;
const githubRepo = import.meta.env.PUBLIC_GITHUB_REPO || '';
---

<AdminLayout title="Modifier le post">
  <div class="max-w-2xl mx-auto">
    <!-- En-tête -->
    <div class="mb-6">
      <a
        href={`${baseUrl}/admin`}
        class="text-sm text-slate-500 hover:text-primary-600 dark:text-slate-400 dark:hover:text-primary-400 transition-colors flex items-center gap-1 mb-2"
      >
        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
        </svg>
        Retour au dashboard
      </a>
      <h1 class="text-2xl font-bold text-slate-900 dark:text-white">
        Modifier le post
      </h1>
    </div>

    <!-- Chargement -->
    <div id="loading-state" class="card p-8 text-center">
      <div class="inline-block w-8 h-8 border-2 border-primary-600 border-t-transparent rounded-full animate-spin"></div>
      <p class="mt-2 text-slate-500 dark:text-slate-400">Chargement du post...</p>
    </div>

    <!-- Erreur -->
    <div id="error-state" class="hidden card p-8 text-center">
      <div class="text-4xl mb-2">⚠️</div>
      <p class="text-slate-700 dark:text-slate-300" id="error-message">Post non trouvé</p>
      <a href={`${baseUrl}/admin`} class="btn-secondary mt-4 inline-flex">
        Retour au dashboard
      </a>
    </div>

    <!-- Éditeur -->
    <form id="post-form" class="hidden space-y-6">
      <!-- Contenu du post -->
      <div class="card p-4">
        <label for="content" class="sr-only">Contenu du post</label>
        <textarea
          id="content"
          name="content"
          class="w-full h-32 resize-none border-0 bg-transparent text-slate-900 dark:text-white placeholder-slate-400 focus:ring-0 text-lg"
          placeholder="Quoi de neuf ?"
          maxlength="280"
          required
        ></textarea>
        <div class="flex items-center justify-between pt-3 border-t border-slate-100 dark:border-slate-700">
          <span id="char-count" class="text-sm text-slate-500 dark:text-slate-400">
            280 caractères restants
          </span>
        </div>
      </div>

      <!-- Upload d'images -->
      <div class="card p-4">
        <label class="label mb-2">Images (max 4)</label>

        <div
          id="drop-zone"
          class="border-2 border-dashed border-slate-300 dark:border-slate-600 rounded-lg p-6 text-center hover:border-primary-500 dark:hover:border-primary-400 transition-colors cursor-pointer"
        >
          <svg class="w-8 h-8 mx-auto text-slate-400 mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
          </svg>
          <p class="text-slate-500 dark:text-slate-400 text-sm">
            Glissez des images ici ou <span class="text-primary-600 dark:text-primary-400">cliquez pour sélectionner</span>
          </p>
          <input type="file" id="file-input" class="hidden" accept="image/jpeg,image/png,image/webp,image/gif" multiple />
        </div>

        <div id="image-preview" class="mt-4 grid grid-cols-2 gap-2 hidden"></div>
      </div>

      <!-- Options de publication -->
      <div class="card p-4">
        <label class="label mb-3">Statut</label>
        <div class="flex flex-wrap gap-3">
          <label class="flex items-center gap-2 cursor-pointer">
            <input type="radio" name="status" value="published" class="text-primary-600 focus:ring-primary-500" />
            <span class="text-slate-700 dark:text-slate-300">Publié</span>
          </label>
          <label class="flex items-center gap-2 cursor-pointer">
            <input type="radio" name="status" value="draft" class="text-primary-600 focus:ring-primary-500" />
            <span class="text-slate-700 dark:text-slate-300">Brouillon</span>
          </label>
          <label class="flex items-center gap-2 cursor-pointer">
            <input type="radio" name="status" value="scheduled" class="text-primary-600 focus:ring-primary-500" />
            <span class="text-slate-700 dark:text-slate-300">Programmé</span>
          </label>
        </div>

        <div id="schedule-picker" class="mt-4 hidden">
          <label for="scheduled-date" class="label">Date et heure de publication</label>
          <input type="datetime-local" id="scheduled-date" name="scheduledDate" class="input" />
        </div>
      </div>

      <!-- Boutons d'action -->
      <div class="flex gap-3">
        <button type="submit" id="submit-btn" class="btn-primary flex-1">
          <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" />
          </svg>
          Enregistrer
        </button>
        <a href={`${baseUrl}/admin`} class="btn-secondary">Annuler</a>
      </div>
    </form>
  </div>
</AdminLayout>

<script define:vars={{ baseUrl, githubRepo }}>
  const GITHUB_REPO = githubRepo;
  const API_BASE = 'https://api.github.com';
  const MAX_IMAGES = 4;
  const MAX_FILE_SIZE = 10 * 1024 * 1024;

  // Récupérer le timestamp depuis l'URL
  const urlParams = new URLSearchParams(window.location.search);
  const timestamp = urlParams.get('id');

  if (!timestamp) {
    document.getElementById('loading-state')?.classList.add('hidden');
    document.getElementById('error-state')?.classList.remove('hidden');
    document.getElementById('error-message').textContent = 'Aucun post spécifié';
  }

  function getToken() {
    return sessionStorage.getItem('github_token');
  }

  function getHeaders() {
    return {
      'Authorization': `Bearer ${getToken()}`,
      'Accept': 'application/vnd.github.v3+json',
      'Content-Type': 'application/json',
    };
  }

  // Récupérer le contenu d'un fichier
  async function getFileContent(path) {
    const response = await fetch(`${API_BASE}/repos/${GITHUB_REPO}/contents/${path}`, {
      headers: getHeaders()
    });
    if (!response.ok) throw new Error('Fichier non trouvé');
    const file = await response.json();
    // Décoder le base64 avec support UTF-8
    return { content: decodeURIComponent(escape(atob(file.content))), sha: file.sha };
  }

  // Créer un blob
  async function createBlob(content, encoding = 'utf-8') {
    const response = await fetch(`${API_BASE}/repos/${GITHUB_REPO}/git/blobs`, {
      method: 'POST',
      headers: getHeaders(),
      body: JSON.stringify({ content, encoding }),
    });
    if (!response.ok) throw new Error('Erreur création blob');
    return response.json();
  }

  // Obtenir la référence HEAD
  async function getRef(branch = 'main') {
    const response = await fetch(`${API_BASE}/repos/${GITHUB_REPO}/git/ref/heads/${branch}`, {
      headers: getHeaders(),
    });
    if (!response.ok) throw new Error('Erreur récupération ref');
    return response.json();
  }

  // Obtenir un commit
  async function getCommit(sha) {
    const response = await fetch(`${API_BASE}/repos/${GITHUB_REPO}/git/commits/${sha}`, {
      headers: getHeaders(),
    });
    if (!response.ok) throw new Error('Erreur récupération commit');
    return response.json();
  }

  // Créer un tree
  async function createTree(baseTreeSha, files) {
    const tree = files.map(f => ({
      path: f.path,
      mode: '100644',
      type: 'blob',
      sha: f.sha,
    }));

    const response = await fetch(`${API_BASE}/repos/${GITHUB_REPO}/git/trees`, {
      method: 'POST',
      headers: getHeaders(),
      body: JSON.stringify({ base_tree: baseTreeSha, tree }),
    });
    if (!response.ok) throw new Error('Erreur création tree');
    return response.json();
  }

  // Créer un commit
  async function createCommit(message, treeSha, parentSha) {
    const response = await fetch(`${API_BASE}/repos/${GITHUB_REPO}/git/commits`, {
      method: 'POST',
      headers: getHeaders(),
      body: JSON.stringify({ message, tree: treeSha, parents: [parentSha] }),
    });
    if (!response.ok) throw new Error('Erreur création commit');
    return response.json();
  }

  // Mettre à jour la référence
  async function updateRef(sha, branch = 'main') {
    const response = await fetch(`${API_BASE}/repos/${GITHUB_REPO}/git/refs/heads/${branch}`, {
      method: 'PATCH',
      headers: getHeaders(),
      body: JSON.stringify({ sha }),
    });
    if (!response.ok) throw new Error('Erreur mise à jour ref');
    return response.json();
  }

  // Créer plusieurs fichiers en un seul commit
  async function createFilesInSingleCommit(files, message) {
    const blobs = await Promise.all(
      files.map(async (f) => {
        const blob = await createBlob(f.content, f.encoding || 'utf-8');
        return { path: f.path, sha: blob.sha };
      })
    );

    const ref = await getRef('main');
    const latestCommitSha = ref.object.sha;
    const latestCommit = await getCommit(latestCommitSha);
    const baseTreeSha = latestCommit.tree.sha;

    const newTree = await createTree(baseTreeSha, blobs);
    const newCommit = await createCommit(message, newTree.sha, latestCommitSha);
    await updateRef(newCommit.sha, 'main');

    return newCommit;
  }

  // Parser le frontmatter
  function parseFrontmatter(content) {
    const match = content.match(/^---\n([\s\S]*?)\n---\n([\s\S]*)$/);
    if (!match) return { data: {}, body: content };

    const frontmatter = match[1];
    const body = match[2];
    const data = {};

    frontmatter.split('\n').forEach(line => {
      const colonIndex = line.indexOf(':');
      if (colonIndex > 0) {
        const key = line.slice(0, colonIndex).trim();
        const value = line.slice(colonIndex + 1).trim();
        if (value === '[]' || value.startsWith('[')) {
          try { data[key] = JSON.parse(value.replace(/'/g, '"')); } catch { data[key] = []; }
        } else {
          data[key] = value;
        }
      }
    });

    return { data, body };
  }

  let images = [];
  let originalPublishedAt = null;

  const form = document.getElementById('post-form');
  const loadingState = document.getElementById('loading-state');
  const errorState = document.getElementById('error-state');
  const contentInput = document.getElementById('content');
  const charCount = document.getElementById('char-count');
  const dropZone = document.getElementById('drop-zone');
  const fileInput = document.getElementById('file-input');
  const imagePreview = document.getElementById('image-preview');
  const schedulePicker = document.getElementById('schedule-picker');
  const submitBtn = document.getElementById('submit-btn');

  // Charger le post
  async function loadPost() {
    if (!timestamp) return;

    try {
      const { content } = await getFileContent(`src/content/posts/${timestamp}.md`);
      const { data, body } = parseFrontmatter(content);

      contentInput.value = body.trim();
      updateCharCount();

      const statusValue = data.status || 'draft';
      const statusRadio = document.querySelector(`input[name="status"][value="${statusValue}"]`);
      if (statusRadio) statusRadio.checked = true;

      if (data.publishedAt) {
        originalPublishedAt = new Date(data.publishedAt);
        const scheduledDateInput = document.getElementById('scheduled-date');
        if (scheduledDateInput) scheduledDateInput.value = originalPublishedAt.toISOString().slice(0, 16);
      }

      if (statusValue === 'scheduled') schedulePicker?.classList.remove('hidden');

      // Images existantes
      const existingImages = data.images || [];
      images = existingImages.map(img => ({
        preview: `${baseUrl}${img.src}`,
        src: img.src,
        alt: img.alt || '',
        isExisting: true,
      }));
      renderImagePreviews();

      loadingState?.classList.add('hidden');
      form?.classList.remove('hidden');
    } catch (error) {
      console.error('Failed to load post:', error);
      loadingState?.classList.add('hidden');
      errorState?.classList.remove('hidden');
    }
  }

  function updateCharCount() {
    const remaining = 280 - contentInput.value.length;
    if (charCount) {
      charCount.textContent = `${remaining} caractères restants`;
      charCount.className = `text-sm ${remaining < 20 ? 'text-red-500' : 'text-slate-500 dark:text-slate-400'}`;
    }
  }

  contentInput?.addEventListener('input', updateCharCount);

  document.querySelectorAll('input[name="status"]').forEach(radio => {
    radio.addEventListener('change', (e) => {
      schedulePicker?.classList.toggle('hidden', e.target.value !== 'scheduled');
    });
  });

  // Drag & Drop
  dropZone?.addEventListener('click', () => fileInput?.click());
  dropZone?.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('border-primary-500'); });
  dropZone?.addEventListener('dragleave', () => dropZone.classList.remove('border-primary-500'));
  dropZone?.addEventListener('drop', (e) => {
    e.preventDefault();
    dropZone.classList.remove('border-primary-500');
    handleFiles(Array.from(e.dataTransfer?.files || []));
  });
  fileInput?.addEventListener('change', () => {
    handleFiles(Array.from(fileInput.files || []));
    fileInput.value = '';
  });

  function handleFiles(files) {
    const validFiles = files.filter(f => f.type.startsWith('image/') && f.size <= MAX_FILE_SIZE);
    const remaining = MAX_IMAGES - images.length;

    validFiles.slice(0, remaining).forEach(file => {
      const reader = new FileReader();
      reader.onload = (e) => {
        images.push({ file, preview: e.target.result, alt: '', isExisting: false });
        renderImagePreviews();
      };
      reader.readAsDataURL(file);
    });
  }

  function renderImagePreviews() {
    if (!imagePreview) return;
    if (images.length === 0) {
      imagePreview.classList.add('hidden');
      imagePreview.innerHTML = '';
      return;
    }
    imagePreview.classList.remove('hidden');
    imagePreview.innerHTML = images.map((img, i) => `
      <div class="relative group aspect-square rounded-lg overflow-hidden bg-slate-100 dark:bg-slate-800">
        <img src="${img.preview}" alt="" class="w-full h-full object-cover" />
        <button type="button" class="remove-image absolute top-2 right-2 p-1 bg-black/50 text-white rounded-full opacity-0 group-hover:opacity-100" data-index="${i}">
          <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" /></svg>
        </button>
      </div>
    `).join('');

    document.querySelectorAll('.remove-image').forEach(btn => {
      btn.addEventListener('click', () => {
        images.splice(parseInt(btn.getAttribute('data-index')), 1);
        renderImagePreviews();
      });
    });
  }

  // Soumission
  form?.addEventListener('submit', async (e) => {
    e.preventDefault();
    if (!timestamp) return;

    const content = contentInput.value.trim();
    if (!content) { alert('Le contenu est requis'); return; }

    const status = document.querySelector('input[name="status"]:checked')?.value || 'published';
    const scheduledDateInput = document.getElementById('scheduled-date');

    let publishedAt = originalPublishedAt || new Date();
    if (status === 'scheduled' && scheduledDateInput?.value) {
      publishedAt = new Date(scheduledDateInput.value);
    }

    submitBtn.setAttribute('disabled', 'true');
    submitBtn.innerHTML = `<svg class="w-5 h-5 mr-2 animate-spin" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>Enregistrement...`;

    try {
      const filesToCommit = [];
      const finalImages = [];

      for (let i = 0; i < images.length; i++) {
        const img = images[i];

        if (img.isExisting && img.src) {
          // Garder l'image existante (pas besoin de la re-committer)
          finalImages.push({ src: img.src, alt: img.alt });
        } else if (img.file) {
          // Nouvelle image à uploader (stockée dans src/assets pour optimisation)
          const ext = img.file.name.split('.').pop() || 'jpg';
          const imageTimestamp = Date.now();
          const imagePath = `src/assets/images/posts/${timestamp}-${i}-${imageTimestamp}.${ext}`;
          const base64Content = img.preview.split(',')[1];

          filesToCommit.push({
            path: imagePath,
            content: base64Content,
            encoding: 'base64',
          });

          finalImages.push({
            src: `@assets/images/posts/${timestamp}-${i}-${imageTimestamp}.${ext}`,
            alt: img.alt,
          });
        }
      }

      // Fichier markdown
      const markdown = [
        '---',
        `status: ${status}`,
        `publishedAt: ${publishedAt.toISOString()}`,
        `images: ${JSON.stringify(finalImages)}`,
        '---',
        '',
        content,
      ].join('\n');

      filesToCommit.push({
        path: `src/content/posts/${timestamp}.md`,
        content: markdown,
        encoding: 'utf-8',
      });

      // Créer tous les fichiers en un seul commit
      await createFilesInSingleCommit(filesToCommit, `Mise à jour post: ${content.slice(0, 50)}...`);

      window.location.href = `${baseUrl}/admin`;
    } catch (error) {
      console.error('Failed to update post:', error);
      alert('Erreur lors de la mise à jour: ' + error.message);
      submitBtn.removeAttribute('disabled');
      submitBtn.innerHTML = `<svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" /></svg>Enregistrer`;
    }
  });

  if (timestamp) loadPost();
</script>
